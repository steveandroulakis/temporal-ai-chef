# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Temporal AI Chef is a CLI demo application that demonstrates how Temporal's deterministic workflows can manage dynamic, multi-step plans generated by an LLM. The key concept illustrated is that Temporal workflows are **deterministic** (ensuring reliable execution) but not **pre-determined** (the exact sequence can be decided dynamically by external systems like LLMs during execution).

**Project Status**: ✅ **COMPLETE** - All stages implemented and tested successfully.

## Development Commands

### Environment Setup
```bash
uv sync
cp .env.example .env
# Edit .env with your OpenAI API key (optional - falls back to mock plans)
```

### Running the Application

**Interactive CLI Experience** (recommended for demos):
```bash
# Terminal 1: Start the worker
uv run chef-worker

# Terminal 2: Run the interactive CLI
uv run temporal-ai-chef
# OR with recipe flag: uv run temporal-ai-chef --recipe "Chicken Parmesan"

# Automated version with embedded worker
uv run chef-auto --recipe "Chicken Parmesan"
```

**Quick Testing & Demos**:
```bash
# 30-second complete demo with embedded worker
uv run chef-demo

# Show dynamic LLM plan generation for 4 different recipes
uv run python temporal_ai_chef/test_different_recipes.py

# Test complete workflow execution (original test)
uv run python temporal_ai_chef/test_complete.py

# Test basic workflow creation (debugging)
uv run python temporal_ai_chef/test_stage1.py
```

### Temporal Server
The application assumes a local Temporal server is running at `localhost:7233`. Users should start this separately:
```bash
temporal server start-dev
```

## Architecture Overview

The application follows Temporal's activity-workflow pattern with real-time state querying and LLM integration:

### Core Workflow Pattern
- **ChefWorkflow**: Main workflow class that orchestrates the cooking process through three phases:
  1. **Planning Phase**: Load tools/ingredients, generate step-by-step plan via LLM or mock
  2. **Execution Phase**: For each step, determine appropriate tool and simulate usage with visual feedback
  3. **Completion Phase**: Return summary of tools used

- **ChefActivities**: Activity class containing all business logic:
  - `get_tools()` / `get_ingredients()`: Load data from JSON files (20 tools, 37 ingredients)
  - `get_plan()`: **LLM-powered** plan generation using GPT-4, falls back to realistic mock plans
  - `get_tool_for_step()`: **LLM-powered** tool selection, falls back to rule-based selection
  - `use_tool()`: Simulate tool usage with randomized delays (0.5-3 seconds)

### LLM Integration Architecture
The application implements a **graceful degradation pattern**:

```python
# LLM-first approach with intelligent fallback
try:
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        return self._get_mock_plan(input.recipe)
    
    client = OpenAI(api_key=api_key)
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=500,
        temperature=0.7
    )
    # Parse and validate response...
except Exception as e:
    activity.logger.warning(f"LLM failed: {e}, using mock plan")
    return self._get_mock_plan(input.recipe)
```

**LLM Plan Quality**: Generates professional cooking instructions with:
- Specific temperatures (375°F, 450°F)
- Precise timing (15-20 minutes, 2-3 minutes per side)  
- Professional techniques (reserve pasta water, cream butter and sugar)
- Context-aware tool selection (Baking Sheet, Rolling Pin, Ladle vs basic tools)

### Temporal-Specific Patterns
The codebase follows Temporal Python SDK patterns:

**Activity Registration**:
```python
# Activities must be registered as individual methods, not class instances
chef_activities = ChefActivities()
worker = Worker(
    client,
    task_queue="chef-task-queue",
    workflows=[ChefWorkflow],
    activities=[
        chef_activities.get_tools,
        chef_activities.get_ingredients,
        chef_activities.get_plan,
        chef_activities.get_tool_for_step,
        chef_activities.use_tool
    ],
    activity_executor=ThreadPoolExecutor(max_workers=5)
)
```

**Activity Execution**:
```python
# Use workflow.execute_activity_method() for class-based activities
tools = await workflow.execute_activity_method(
    chef_activities.get_tools,
    start_to_close_timeout=timedelta(seconds=10)
)
```

**Enhanced State Management with Queries**:
```python
# Workflow maintains detailed queryable state for real-time CLI updates
@workflow.query
def get_state(self) -> WorkflowState:
    return self._state

# Enhanced state includes:
# recipe, plan, current_step, current_step_index, completed_steps, 
# used_tools, current_tool, current_tool_result, used_ingredients, 
# current_ingredients, is_complete, status, step_status
```

### Real-time CLI Architecture
The CLI implements **high-frequency state polling** for smooth user experience:

```python
# Poll every 500ms for responsive updates
while True:
    state = await handle.query(ChefWorkflow.get_state)
    
    # Show plan when available
    if state.plan and not plan_displayed:
        print("\n[PLANNING] 📝")
        for i, step in enumerate(state.plan, 1):
            print(f"- Step {i}: {step}")
    
    # Show tool usage with emojis
    if state.step_status == "using_tool" and state.current_tool:
        tool_emoji = {"Chopping Board": "🔪", "Oven": "🔥", ...}
        print(f"-> Using tool: [{state.current_tool}]... {tool_emoji} (Simulating work...)")
    
    await asyncio.sleep(0.5)  # High-frequency polling
```

### Data Flow Architecture
1. **Input**: `ChefWorkflowInput(recipe, goal)`
2. **State Transitions**: "planning" → "executing" → "completed" with sub-states
3. **Real-time Queries**: CLI polls `get_state()` every 500ms for live updates
4. **LLM Interaction**: Dynamic plan generation and tool selection during execution
5. **Output**: Professional summary with tools used and "Bon appétit!" message

### File Structure
- `workflow.py`: Core workflow logic with enhanced state management and query methods
- `activities.py`: **LLM-powered activities** with fallback implementations (plan generation, tool selection, simulation)
- `worker.py`: Temporal worker that executes activities with proper thread pool
- `run_chef.py`: **Interactive CLI client** with real-time state polling and formatted display (supports `--recipe` flag)
- `run_with_worker.py`: **Automated CLI client** with embedded worker management (`chef-auto` command)
- `data/`: JSON files containing tools (20 items) and ingredients (37 items)
- `test_end_to_end.py`: **Primary demo script** - 30-second complete demonstration
- `test_different_recipes.py`: **LLM showcase** - demonstrates dynamic plan generation for 4 different recipes
- `test_complete.py`: Complete workflow test with embedded worker
- `test_stage1.py`: Basic workflow creation test (debugging)

## Development Workflow

### Testing Strategy
Multiple test approaches for different use cases:
- `test_end_to_end.py`: **Primary demo** - Complete 30-second demonstration
- `test_different_recipes.py`: **LLM showcase** - Shows dynamic plan generation variety
- `test_complete.py`: Original complete workflow test
- `test_stage1.py`: Basic workflow functionality test

### Implementation Status
- ✅ **Stage 1 Complete**: Basic infrastructure with mock implementations
- ✅ **Stage 2 Complete**: **LLM integration** with GPT-4 for plan generation and tool selection
- ✅ **Stage 3 Complete**: **CLI client** with real-time state polling and visual formatting
- ✅ **Stage 4 Complete**: Polish, error handling, comprehensive testing, documentation

### Key Implementation Notes

**Activity Class Pattern**: Activities must be class-based with `@activity.defn` decorators on methods, registered as individual method references.

**Dataclass Inputs**: All activity inputs use dataclasses for forward compatibility:
```python
@dataclass
class PlanInput:
    goal: str
    recipe: str
    tools: List[str]
    ingredients: List[str]
```

**Task Queue**: All components use `"chef-task-queue"` for coordination.

**LLM Fallback Pattern**: Always implement graceful degradation to mock implementations for demos without API keys.

**State Polling**: The CLI queries workflow state every 500ms to show:
- Real-time plan generation (planning phase)
- Step-by-step execution progress
- Tool usage with visual indicators (emojis)
- Tool usage results (✅ Successfully used [tool] for: [step])
- Completion status with summary

**Race Condition Prevention**: The UI waits for `step_status == "using_tool"` before displaying step information to ensure ingredients are correctly aligned with their respective steps.

### Actual CLI Output Format
The implemented CLI matches the PRD specification exactly:
```
🍳 Welcome to Temporal AI Chef!
==================================================
What would you like to cook today?
> Chicken Parmesan

🧠 AI Chef is thinking about: Chicken Parmesan...

[PLANNING] 📝
- Step 1: Preheat the oven to 450 degrees F and grease a baking sheet with olive oil.
- Step 2: Prepare the chicken breasts by pounding them flat using the flat side of a meat mallet or rolling pin.
...

[EXECUTING] 🔥

[EXECUTING STEP 1: Preheat the oven to 450 degrees F and grease a baking sheet with olive oil.]
-> Using tool: [Baking Sheet]... 🔧 (Simulating work...)

[EXECUTING STEP 2: Prepare the chicken breasts by pounding them flat...]
-> Using tool: [Rolling Pin]... 🔧 (Simulating work...)

==================================================
✅ DONE!
📄 Summary: Cooked Chicken Parmesan using Baking Sheet, Rolling Pin, Mixing Bowl, Oven, Saucepan, Ladle
🍽️  Bon appétit!
```

## LLM Integration Details

### Plan Generation
- **Model**: GPT-4 for high-quality cooking instructions
- **Context**: Considers available tools and ingredients from JSON files
- **Output**: 4-8 professional cooking steps with specific techniques, temperatures, and timing
- **Fallback**: Recipe-specific mock plans (Chicken Parmesan, Pasta, generic)

### Tool Selection  
- **Model**: GPT-4 with lower temperature (0.3) for consistent selections
- **Validation**: Ensures selected tool exists in available tools list
- **Fallback**: Rule-based tool selection using keyword matching

### Dynamic Recipe Demonstration
The `test_different_recipes.py` script demonstrates LLM plan generation for:
- **Spaghetti Carbonara**: 7 pasta-specific steps with sauce techniques
- **Chocolate Chip Cookies**: 8 baking steps with precise temperatures
- **Beef Stir Fry**: 8 wok-cooking steps with vegetable prep sequences  
- **French Toast**: 6 breakfast-specific steps with skillet techniques

Each recipe produces completely different, contextually appropriate, professional-quality plans.

## Presentation & Demo Usage

**For Temporal Concept Demonstrations**:
1. `uv run chef-demo` - Shows complete deterministic but not pre-determined workflow
2. `uv run python temporal_ai_chef/test_different_recipes.py` - Demonstrates dynamic LLM-driven plan generation
3. `uv run temporal-ai-chef --recipe "Chicken Caesar Salad"` - Interactive experience for audience participation
4. `uv run chef-auto --recipe "Pasta Carbonara"` - Automated demo with embedded worker

**Key Talking Points**:
- Workflows are deterministic (reliable execution) but not pre-determined (LLM decides steps)
- Real-time state querying enables rich user experiences during execution
- LLM integration shows how AI can drive business logic while maintaining reliability
- Professional application quality with error handling and graceful degradation